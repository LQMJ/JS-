###  闭包
-  闭包定义：
   + (1)函数嵌套函数；
   + (2)子函数引用父函数的参数或者变量；
   + (3)子函数被外界所引用；
   + (4)这时候父级就形成了闭包环境（父级的栈内存不会被销毁）父级的参数或者变量不会被浏览器的垃圾机制回收；
   + 这时候打印父级函数的返回值查看scopes下有一个closure，这就是闭包
- 闭包的应用：存值

### var、let、const的区别
-  var
   + 当通过var创建一个变量的时候，会进行预解析（变量提升）；
   + 因为var创建的变量会预解析，所以var创建的变量会被当做属性存到全局的活动变量对象下（window下）；
   + 不支持块级作用域
   + 不会主动存循环的值

- let
   + 通过let创建的变量不会预解析(变量提升)
   + 不会在window下挂属性
   + 支持块级作用域
   + 会存储每次循环的值
   + 有暂存死区（在定义变量上方访问不到这个变量，这个空间叫暂存死区）
   + 不能声明同名的变量、函数、参数

- const（常量）当声明一个变量，不允许改变的时候就使用const
   + 不能声明同名的变量、函数、参数
   + 支持块级作用域
   + 在定义变量上方访问不到这个变量，这个空间叫暂存死区
### 面向对象
- 单例模式
 
    单例模式:
      
      单例：单独的实例
      实例：描述具体的是一个事务
      构造函数：抽象一个类的封装过程

- 高级单例模式：

      让当前这个实例功能更加强大，还可以隐藏或者暴露细节信息；

      (function(){
          function sum(){

          }
          return {

          }
      })()

- 高级单例模式的作用：
 (1)让当前的这个实例功能更加强大，还可以隐藏或者暴露内部细节信息
 (2)解决命名冲突的问题

 高级单例模式的写法：
```js
   let obj = (function(){
            return{
              //对象
              }
            })()
   // 最后让一个变量去收这个功能强大的对象
```
  

- 解决命名冲突的问题：

 1.封闭空间 （把变量或者函数放到函数中）
```js
      let a  = 10 ;
      (function(){
          let a = 20;
      })()
```

 2.命名空间
```js
   let obj ={
       name:10;
   }
     let name = 10;
     obj.name
   let obj2 ={
       name:20;
   }
     let name = 20;
     obj2.name
```

- 工厂模式
 
    + 工厂模式为了*批量*生产

    + 函数 目的是为了复用

   


          